// This file creates the internal module & binding loaders used by built-in
// modules. In contrast, user land modules are loaded using
// lib/internal/modules/cjs/loader.js (CommonJS Modules) or
// lib/internal/modules/esm/* (ES Modules).
//
// This file is compiled and run by node.cc before bootstrap/node.js
// was called, therefore the loaders are bootstraped before we start to
// actually bootstrap Node.js. It creates the following objects:
//
// C++ binding loaders:
// - process.binding(): the legacy C++ binding loader, accessible from user land
//   because it is an object attached to the global process object.
//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()
//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees
//   about the stability of these bindings, but still have to take care of
//   compatibility issues caused by them from time to time.
// - process._linkedBinding(): intended to be used by embedders to add
//   additional C++ bindings in their applications. These C++ bindings
//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag
//   NM_F_LINKED.
// - internalBinding(): the private internal C++ binding loader, inaccessible
//   from user land because they are only available from NativeModule.require()
//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()
//   and have their nm_flags set to NM_F_INTERNAL.
//
// Internal JavaScript module loader:
// - NativeModule: a minimal module system used to load the JavaScript core
//   modules found in lib/**/*.js and deps/**/*.js. All core modules are
//   compiled into the node binary via node_javascript.cc generated by js2c.py,
//   so they can be loaded faster without the cost of I/O. This class makes the
//   lib/internal/*, deps/internal/* modules and internalBinding() available by
//   default to core modules, and lets the core modules require itself via
//   require('internal/bootstrap/loaders') even when this file is not written in
//   CommonJS style.
//
// Other objects:
// - process.moduleLoadList: an array recording the bindings and the modules
//   loaded in the process and the order in which they are loaded.

// 首先运行的模块，用于执行模块的加载以及构建之中

'use strict';

/**
 * @param process 进程
 * @param getBinding  传统的C++模块绑定器
 * @param getLinkedBinding 额外的C++模块绑定器
 * @param getInternalBinding 私有的C++模块绑定器
 */

(function bootstrapInternalLoaders(process, getBinding, getLinkedBinding,
                                   getInternalBinding) {
  /**
   * ES6新增的Reflect对象，内置对象，封装了一些方法以及处理
   * @param apply 与Function中的apply一样，Reflect.apply(func, obj, args);
   * @param deleteProperty 与delete object.attr作用一致，用于删除对象属性
   * @param get 与object.attr作用一致，获取对象的对应属性
   * @param getOwnPropertyDescriptor(obj, attr) 与Object.getOwnPropertyDescriptor(obj, attr), 获取对象的属性描述
   * @param has 与attr in obj一致，获取对象属性的存在性
   * @param set 与obj.attr = xxx一致，设置对象的属性值
   */
  const {
    apply: ReflectApply,
    deleteProperty: ReflectDeleteProperty,
    get: ReflectGet,
    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,
    has: ReflectHas,
    set: ReflectSet,
  } = Reflect;
  /**
   * Object对象的部分方法
   * Object.prototype.hasOwnProperty 获取对象属性的存在性
   * Object.create 创建一个某个原型为基础的对象
   * Object.defineProperty 定义某个对象的属性
   * Object.keys 获取某个对象的键
   */
  const {
    prototype: {
      hasOwnProperty: ObjectHasOwnProperty,
    },
    create: ObjectCreate,
    defineProperty: ObjectDefineProperty,
    keys: ObjectKeys,
  } = Object;

  // Set up process.moduleLoadList
  // 在process定义所需要加载的模块的列表属性moduleLoadList，初始值为[]
  const moduleLoadList = [];
  ObjectDefineProperty(process, 'moduleLoadList', {
    value: moduleLoadList,
    configurable: true, // 可删除
    enumerable: true, // 可枚举
    writable: false // 不可修改
  });

  // Set up process.binding() and process._linkedBinding()
  // 加载传统的C++模块以及扩展的C++模块
  {
    const bindingObj = ObjectCreate(null); // 创建一个{}对象

    // 在process上设置binding方法，参数为需要绑定的模块（module）
    process.binding = function binding(module) {
      module = String(module); // 转换为字符串类型
      let mod = bindingObj[module]; // 检测bindingObj对象是否含有该模块（module）
      if (typeof mod !== 'object') { // 如果没有该模块， mod值应该为undefined， 该if会执行
        mod = bindingObj[module] = getBinding(module); // getBinding获取对应的C++模块
        moduleLoadList.push(`Binding ${module}`); // 将已经加载的模块添加进moduleLoadList数组变量
      }
      return mod; // 返回加载的模块
    };
  
    // 在process上设置_linkedBinding方法，参数为需要加载的模块（module）
    process._linkedBinding = function _linkedBinding(module) {
      module = String(module);
      let mod = bindingObj[module];
      if (typeof mod !== 'object')
        mod = bindingObj[module] = getLinkedBinding(module);
      return mod;
    };
  }

  // Set up internalBinding() in the closure
  // 加载私有的C++模块
  let internalBinding;
  {
    const bindingObj = ObjectCreate(null);
    internalBinding = function internalBinding(module) {
      let mod = bindingObj[module];
      if (typeof mod !== 'object') {
        mod = bindingObj[module] = getInternalBinding(module);
        moduleLoadList.push(`Internal Binding ${module}`);
      }
      return mod;
    };
  }

  const { ContextifyScript } = process.binding('contextify');

  // Set up NativeModule
  // 加载本地模块
  function NativeModule(id) {
    this.filename = `${id}.js`;
    this.id = id;
    this.exports = {};
    this.reflect = undefined;
    this.exportKeys = undefined;
    this.loaded = false;
    this.loading = false;
  }
  
  NativeModule._source = getBinding('natives');
  NativeModule._cache = {};

  const config = getBinding('config');

  // Think of this as module.exports in this file even though it is not
  // written in CommonJS style.
  // 本地模块的导入导出
  const loaderExports = { internalBinding, NativeModule }; // 导出本地模块以及私有模块
  const loaderId = 'internal/bootstrap/loaders';
  NativeModule.require = function(id) {
    // 返回已存在的模块
    if (id === loaderId) {
      return loaderExports;
    }

    // 返回缓存的模块
    const cached = NativeModule.getCached(id);
    if (cached && (cached.loaded || cached.loading)) {
      return cached.exports;
    }
    
    // 如果为不存在的模块，则抛出错误
    if (!NativeModule.exists(id)) {
      // Model the error off the internal/errors.js model, but
      // do not use that module given that it could actually be
      // the one causing the error if there's a bug in Node.js
      // eslint-disable-next-line no-restricted-syntax
      const err = new Error(`No such built-in module: ${id}`);
      err.code = 'ERR_UNKNOWN_BUILTIN_MODULE';
      err.name = 'Error [ERR_UNKNOWN_BUILTIN_MODULE]';
      throw err;
    }

    moduleLoadList.push(`NativeModule ${id}`);// 将本地模块加入已加载moduleLoadList数组中

    const nativeModule = new NativeModule(id); // 初始化本地模块对象

    nativeModule.cache(); // 缓存加载的模块
    nativeModule.compile(); // 加载编译模块

    return nativeModule.exports; // 导出本地模块
  };

  // 对引用内部核心模块的单独处理（node-inspect模块以及v8模块）
  NativeModule.requireForDeps = function(id) {
    if (!NativeModule.exists(id) ||
        // TODO(TimothyGu): remove when DEP0084 reaches end of life.
        id.startsWith('node-inspect/') ||
        id.startsWith('v8/')) {
      id = `internal/deps/${id}`;
    }
    return NativeModule.require(id);
  };

  // 获取已经缓存的模块
  NativeModule.getCached = function(id) {
    return NativeModule._cache[id];
  };

  // 检查要加载的模块是否在需要加载的列表中
  NativeModule.exists = function(id) {
    return NativeModule._source.hasOwnProperty(id);
  };
  
  // 暴露内部模块时的特殊处理
  if (config.exposeInternals) {
    // 判断是否没有加载内部模块，false为加载了内部模块
    NativeModule.nonInternalExists = function(id) {
      // Do not expose this to user land even with --expose-internals
      if (id === loaderId) {
        return false; // 加载的为内部模块，直接返回false
      }
      return NativeModule.exists(id); // 否则判断本地模块中是否包含该模块
    };
    // 判断是不是内部模块， true为是
    NativeModule.isInternal = function(id) {
      // Do not expose this to user land even with --expose-internals
      return id === loaderId;
    };
  } else {
    NativeModule.nonInternalExists = function(id) {
      return NativeModule.exists(id) && !NativeModule.isInternal(id);
    };

    NativeModule.isInternal = function(id) {
      return id.startsWith('internal/') ||
          (id === 'worker_threads' &&
           !process.binding('config').experimentalWorker);
    };
  }

  // 获取需要加载的资源
  NativeModule.getSource = function(id) {
    return NativeModule._source[id];
  };

  // 对脚本进行包裹，符合COMMONJS规范
  NativeModule.wrap = function(script) {
    return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];
  };

  // 包裹的代码块
  NativeModule.wrapper = [
    '(function (exports, require, module, process) {',
    '\n});'
  ];
  
  /**
   * 获取目标对象的属性
   * @param target 要获取的目标对象
   * @param property 要获取的对象的目标属性
   * @param receiver 需要设置的上下文
   */
  const getOwn = (target, property, receiver) => {
    return ReflectApply(ObjectHasOwnProperty, target, [property]) ?
      ReflectGet(target, property, receiver) :
      undefined;
  };

  // 对模块进行加载编译
  NativeModule.prototype.compile = function() {
    let source = NativeModule.getSource(this.id); // 获取到对应的模块
    source = NativeModule.wrap(source); // 包裹COMMONJS规范代码块

    this.loading = true; // 设置加载状态为true

    try {
      const script = new ContextifyScript(source, this.filename);// 获取对应的js文件
      // Arguments: timeout, displayErrors, breakOnSigint
      const fn = script.runInThisContext(-1, true, false); // 在当前上下文执行js文件
      const requireFn = this.id.startsWith('internal/deps/') ? // 是否需要引用核心内部模块，有则进行深层引用
        NativeModule.requireForDeps :
        NativeModule.require;
      fn(this.exports, requireFn, this, process); // 执行该模块

      // 实验性模块的处理
      if (config.experimentalModules && !NativeModule.isInternal(this.id)) {
        this.exportKeys = ObjectKeys(this.exports); // 获取暴露的所有属性
  
        /**
         * 更新导出对象的属性值的方法
         * @param property 需要更新的属性名
         * @param value 需要更新的属性值
         */
        const update = (property, value) => {
          if (this.reflect !== undefined &&
              ReflectApply(ObjectHasOwnProperty,
                           this.reflect.exports, [property]))
            this.reflect.exports[property].set(value);
        };

        // 定义一个处理对象
        const handler = {
          __proto__: null,
          /**
           * 定义对象属性时的劫持
           * @param target 目标对象
           * @param prop 属性名
           * @param descriptor 属性描述
           */
          defineProperty: (target, prop, descriptor) => {
            // Use `Object.defineProperty` instead of `Reflect.defineProperty`
            // to throw the appropriate error if something goes wrong.
            ObjectDefineProperty(target, prop, descriptor);
            if (typeof descriptor.get === 'function' && // 如果需要定义get函数且handler中没有get函数
                !ReflectHas(handler, 'get')) {
              /**
               * 定义get方法
               * @param target 目标对象
               * @param prop 属性
               * @param receiver 上下文
               */
              handler.get = (target, prop, receiver) => {
                const value = ReflectGet(target, prop, receiver);
                if (ReflectApply(ObjectHasOwnProperty, target, [prop]))
                  update(prop, value); // 更新对应的映射的属性值
                return value;
              };
            }
            update(prop, getOwn(target, prop)); // 更新对应的映射的属性值
            return true;
          },
          /**
           * 删除对象属性的劫持
           * @param target 目标对象
           * @param prop 目标属性
           */
          deleteProperty: (target, prop) => {
            if (ReflectDeleteProperty(target, prop)) {
              update(prop, undefined); // 更新对应的映射的属性值为undefined
              return true;
            }
            return false;
          },
          /**
           * get方法时的劫持
           * @param target 目标对象
           * @param prop 目标属性
           * @param value 目标值
           * @param receiver 上下文
           */
          set: (target, prop, value, receiver) => {
            const descriptor = ReflectGetOwnPropertyDescriptor(target, prop);
            if (ReflectSet(target, prop, value, receiver)) {
              if (descriptor && typeof descriptor.set === 'function') { // 如果目标对象定义了set函数
                for (const key of this.exportKeys) {
                  update(key, getOwn(target, key, receiver)); // 更新导出的键值对对应的映射属性的所有的键值
                }
              } else {
                update(prop, getOwn(target, prop, receiver)); // 没有定义set函数则直接更新对应的映射属性的键值
              }
              return true;
            }
            return false;
          }
        };

        this.exports = new Proxy(this.exports, handler); // 使用Proxy进行代理注入，劫持部分对象的方法进行自己的操作
      }

      this.loaded = true; // 已加载状态置为true
    } finally {
      this.loading = false; // 加载状态置为false
    }
  };

  // 设置缓存
  NativeModule.prototype.cache = function() {
    NativeModule._cache[this.id] = this;
  };

  // This will be passed to the bootstrapNodeJSCore function in
  // bootstrap/node.js.
  return loaderExports;
});
